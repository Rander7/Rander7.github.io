<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/05/17/%E9%93%BE%E8%A1%A8%E4%BE%8B%E9%A2%98%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
      <url>/2022/05/17/%E9%93%BE%E8%A1%A8%E4%BE%8B%E9%A2%98%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="链表例题个人总结"><a href="#链表例题个人总结" class="headerlink" title="链表例题个人总结"></a>链表例题个人总结</h1><p>上期谈到的顺序表有许多不足，于是我们引入链表这个新的线性表</p><p>首先要理解为什么有链表，链表为了解决什么问题而产生的</p><p>链表的结点空间可动态申请，释放，插入删除元素时候不需要移动数据元素</p><p>我们先创建一个链表</p><pre><code class="c">typedef struct LNode &#123;    ElemType data;//数据域    struct LNode* next;//指针域&#125;LNode, * LinkList;//LinkList是指向链表的指针</code></pre><p>以下的链表创建如果没有特别声明就是创建有头结点的链表，他的好处是链表第一位置上的操作和其他位置一致无无须任何特殊处理，还有就是空表和非空表的处理统一（头结点数据域可为空，不计入链表的长度）</p><p>然后这次我们主要想利用链表解决以下问题：</p><p><strong>1.链表的建立，删除，插入，查找</strong></p><p><strong>2.两个链表按元素交集，并集原则合并</strong></p><p><strong>3.解决一元多项式相加问题</strong></p><p><strong>4.解决约瑟夫环问题</strong></p><p>以下是链表的几道基础例题：</p><h2 id="1-题目内容："><a href="#1-题目内容：" class="headerlink" title="1. 题目内容："></a>1. 题目内容：</h2><p>编程实现单链表的下列基本操作函数。<br>(1)void CreatList(LinkList &amp;L, int n):<br>依次输入 n 个数据，并依次建立各个元素结点，逐个插入到链表尾；建立带表头结点的单链<br>表 L；<br>(2) void ListPrint(LinkList L): 将单链表 L 的数据元素从表头到表尾依次显示。<br>(3) bool ListInsert (LinkList &amp;L, int i,ElemType e):<br>在带头结点的单链表 L 中第 i 个数据元素之前插入数据元素 e，并返回 true。如果 i 值非法，<br>则显示“Insertion Location Error”，并返回 false;<br>(4) bool ListDelete(LinkList &amp;L, int n, ElemType &amp;e) &#x2F;&#x2F;删除链表的第 n 个元素，用 e 返回其值，并<br>返回 true。如果 i 值非法，则显示“Deletion Location Error”，并返回 false;<br> (5) int ListLength(LinkList L);&#x2F;&#x2F;求链表 L 的表长<br>输入格式：<br>四行数据，第一行的整数表示要建立的单链表的元素个数，第二行整数表示依次输入的数<br>据，两个整数之间以空格分隔，第三行的两个整数分别表示要插入的数和插入位置，第四行表<br>示要删除数的位置。<br>输出格式：<br>三行数据，第一行整数表示已删除的数，第二行表示链表的长，第三行表示目前链表的数<br>据元素(依次从表头至表尾)。</p><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define true 1#define false 0typedef intElemType;typedef struct LNode &#123;    ElemType data;//数据域    struct LNode* next;//指针域&#125;LNode, * LinkList;//LinkList是指向链表的指针  int main()&#123;    void CreatList(LinkList &amp; L, int n);    void ListPrint(LinkList L);    bool ListInsert(LinkList &amp; L, int i, ElemType e);    bool ListDelete(LinkList &amp; L, int n, ElemType &amp; e);    int ListLength(LinkList L);    int n = 0,//链表元素个数        i = 0,//想插入元素的位序        j = 0;//想删除元素的位序    LinkList K;//初始化链表K    ElemType e;//插入元素的值    ElemType f;//保存删除元素的值    printf(&quot;请输入链表元素个数\n&quot;);    scanf(&quot;%d&quot;, &amp;n);    CreatList(K, n);    printf(&quot;请输入你想在第几个元素之前插入元素e,并输入e的值\n&quot;);    scanf(&quot;%d %d&quot;, &amp;i,&amp;e);    ListInsert(K, i, e);    printf(&quot;请输入你想删除第几个元素\n&quot;);    scanf(&quot;%d&quot;, &amp;j);    ListDelete(K, j, f);    printf(&quot;删除数的值为%d\n&quot;,f);    printf(&quot;操作后该链表表长为%d\n&quot;, ListLength(K));    ListPrint(K);     return 0;&#125; void CreatList(LinkList&amp; L, int n)//尾插法，正序输入(头插法（倒序输入）也行，不过会麻烦一点)&#123;    LNode* p = NULL;//p是一个结构类型指针    LNode* r = NULL;//尾指针    L = (LinkList)malloc(sizeof(LNode));//创造头结点    L-&gt;next = NULL;//头节点指向空    r = L;//创造尾指针指向头结点（此时是头指针）    int i = 0;    printf(&quot;请输入%d个元素\n&quot;, n);    for (i = 0; i &lt;n; i++) &#123;        p = (LinkList)malloc(sizeof(LNode));//创造新结点        scanf(&quot;%d&quot;, &amp;p-&gt;data);//输入该结点数据域        p-&gt;next = NULL;//插入结点指针域置空        r-&gt;next = p;//在上一结点指针域存放该结点地址        r = p;//让尾指针指向当前的新结点（最后一个结点）    &#125;&#125; void ListPrint(LinkList L)&#123;    LNode* p = NULL;    p = L-&gt;next;//p指向首元结点，从首元结点开始打印    while (p)    &#123;        printf(&quot;%d &quot;, p-&gt;data);        p = p-&gt;next;    &#125;&#125; bool ListInsert(LinkList&amp; L, int i, ElemType e)&#123;    LNode* p = NULL;//指向插入位置i的前驱结点的指针,i-1的指针    LNode* s = NULL;//指向插入结点的指针    int j = 0;    p = L;//p指向头结点，j赋为0    while (p &amp;&amp; j &lt; i - 1)    &#123;        p = p-&gt;next;        j++;    &#125;    if (!p &amp;&amp; j &gt; i - 1)//判断i值非法    &#123;        printf(&quot;Insertion Location Error&quot;);        return false;    &#125;         s = (LinkList)malloc(sizeof(LNode));        s-&gt;data = e;//将e赋给插入结点的数据域        s-&gt;next = p-&gt;next;//将i-1结点的指针域赋给s的指针域，也就是现在s的next域存放原来i位置的结点        p-&gt;next = s;//让i-1结点的next域存放s结点的地址         return true; &#125; bool ListDelete(LinkList&amp; L, int n, ElemType&amp; e)&#123;    LNode* p = NULL;    LNode* q = NULL;    int j = 0;    //还是找i-1结点，不过判断要p-&gt;next因为主要要保证i结点存在    p = L;//p指向头结点，j赋为0,这里不要改成指向头结点，不然n为1时候，下面判断j&gt;n-1失效    while (p-&gt;next &amp;&amp; j &lt; n - 1)    &#123;        j++;        p = p-&gt;next;    &#125;    if (!p-&gt;next &amp;&amp; j &gt; n - 1)    &#123;        printf(&quot;Deletion Location Error&quot;);        return false;    &#125;     q = p-&gt;next;//q就是指向当前i位置的指针    p-&gt;next = q-&gt;next;//i-1的指针next域存放i+1的地址    e = q-&gt;data;//保存i位置的数据域方便返回    free(q);//释放i结点（c++的话前面用new这里用delete）    return true;&#125; int ListLength(LinkList L)&#123;    LNode* p = NULL;    int j = 0;    p = L-&gt;next;//计算表长从首元结点开始，j赋为0（第一次进去就0++，没进去就是0）    while (p)    &#123;        p = p-&gt;next;        j++;    &#125;    return j;&#125;</code></pre><h2 id="2-题目内容："><a href="#2-题目内容：" class="headerlink" title="2.题目内容："></a>2.题目内容：</h2><p>设有链表 A 和 B，其中的数据内容均为整型数值，且都按增序排列，生成新的链表 C，满足下<br>列要求：C &#x3D; A U B(C 中元素为 A 和 B 的并集)，且 C 中元素按增序排列。<br>输入格式：<br>二行数据，第一行的整数表示 A 表的数据元素，第二行整数 B 表的数据元素，两个整数之间以<br>空格分隔，每一行-1 表示数据的结尾（-1 不属于这个表中的数据元素）。<br>输出格式：<br>一行整数，从表头开始依次显示链表 C 的数据元素，数字间用空格分开。</p><h2 id="2’-如2中叙述一样，不过C取A-n-B，即A和B的共同元素"><a href="#2’-如2中叙述一样，不过C取A-n-B，即A和B的共同元素" class="headerlink" title="2’ 如2中叙述一样，不过C取A n B，即A和B的共同元素"></a>2’ 如2中叙述一样，不过C取A n B，即A和B的共同元素</h2><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define true 1#define false 0typedef intElemType;typedef struct LNode &#123;    ElemType data;//数据域    struct LNode* next;//指针域&#125;LNode, * LinkList; int main()&#123;    void CreatList(LinkList &amp; L);    void ListPrint(LinkList L);    //void CmbList(LinkList  LA, LinkList  LB, LinkList LC);//取并集    void findlist(LinkList LA, LinkList LB, LinkList LC);//取交集    LinkList A, B;    LinkList C;    C = (LinkList)malloc(sizeof(LNode));//先创建C链表头节点    C-&gt;next = NULL;//并令其指针域指向空    printf(&quot;请输入A链表元素的元素(输入-1停止)\n&quot;);    CreatList(A);    printf(&quot;请输入B链表元素的元素(输入-1停止)\n&quot;);    CreatList(B);    //CmbList(A, B, C);    findlist(A, B, C);    ListPrint(C);    return 0;&#125; void CreatList(LinkList&amp; L)//尾插法，正序输入&#123;    LNode* p = NULL;//p是一个结构类型指针    LNode* r = NULL;    L = (LinkList)malloc(sizeof(LNode));//创造头结点    L-&gt;next = NULL;//头节点指向空    r = L;//创造尾指针指向头结点（此时是头指针）    int t = 0;        while(1)//while循环令其一直输入元素，直到出现-1然后break跳出循环    &#123;         scanf(&quot;%d&quot;, &amp;t);//输入该结点数据域        if (t!= -1)         &#123;            p = (LinkList)malloc(sizeof(LNode));//创造新结点            p-&gt;next = NULL;//插入结点指针域置空            p-&gt;data = t;                            r-&gt;next = p;//在上一结点指针域存放该结点地址            r = p;//让尾指针指向当前的新结点（最后一个结点）        &#125;        else            break;            &#125;&#125; void ListPrint(LinkList L)&#123;    LNode* p = NULL;    p = L-&gt;next;//p指向首元结点，从首元结点开始打印    while (p)    &#123;        printf(&quot;%d &quot;, p-&gt;data);        p = p-&gt;next;    &#125;&#125;   void ListInsert(LinkList&amp; L, int i, ElemType e)&#123;    LNode* p = NULL;//插入位置的前驱结点的指针,i-1的指针    LNode* s = NULL;//插入结点的指针    int j = 0;    p = L;//p指向头结点，j赋为0    while (p &amp;&amp; j &lt; i - 1)    &#123;        p = p-&gt;next;        j++;    &#125;    s = (LinkList)malloc(sizeof(LNode));    s-&gt;data = e;    s-&gt;next = p-&gt;next;    p-&gt;next = s; &#125;/*void CmbList(LinkList LA, LinkList LB, LinkList LC)&#123;    void ListInsert(LinkList &amp; L, int i, ElemType e);    int i = 0;    LinkList a = NULL;    LinkList b = NULL;    a = LA-&gt;next;//a指向A的首元结点    b = LB-&gt;next;    for (i = 0; a || b; i++)//ab至少有一个非空    &#123;        if (a &amp;&amp; b)        &#123;            if (a-&gt;data == b-&gt;data) //每当相等情况时就任意移动一方让其指向下一结点再比较，这里选择移动b            &#123;                b = b-&gt;next;                i--;//每次循环i++，但是相等时候我们并没有插入元素只是移动指针，所以我们要i--                //也就是i他要作为插入C的位序数，你不插入外循环要++，你这里需要--来抵消            &#125;            else if (a-&gt;data &lt; b-&gt;data)//如果a的data小于b，把a的data插入C中            &#123;                ListInsert(LC,i+1,a-&gt;data);//这里i+1，输入的是位序，不是下标                a = a-&gt;next;            &#125;            else if (a-&gt;data &gt; b-&gt;data)             &#123;                ListInsert(LC, i + 1, b-&gt;data);                b = b-&gt;next;            &#125;                    &#125;        else if (a)//进入这里说明a还没指向空，b已经空了        &#123;            ListInsert(LC, i + 1, a-&gt;data);//把a剩下所有的全部插进C中            a = a-&gt;next;        &#125;        else        &#123;            ListInsert(LC, i + 1, b-&gt;data);            b = b-&gt;next;        &#125;    &#125;&#125;*/void findlist(LinkList LA, LinkList LB, LinkList LC)&#123;    void ListInsert(LinkList &amp; L, int i, ElemType e);    LNode* a = NULL;    LNode* b = NULL;    a = LA-&gt;next;    b = LB-&gt;next;    int i = 0;    for (i = 0; a &amp;&amp; b; i++)//ab有一个为空就可以跳出循环，取交集，一方为空就不用继续了    &#123;                    if (a-&gt;data == b-&gt;data) //相等就插入，然后同时移动a和b            &#123;                ListInsert(LC, i+1, a-&gt;data);                a = a-&gt;next;                b = b-&gt;next;            &#125;            else if (a-&gt;data &lt; b-&gt;data)             &#123;                a = a-&gt;next;                i--;//注意这里每次没有对应到i就减1，没插入就要减            &#125;      //这里--后0++--还是0，这里i是代表lc元素的下标            else if (a-&gt;data&gt; b-&gt;data)            &#123;                b = b-&gt;next;                i--;            &#125;        &#125;             &#125;</code></pre><p>（comlist取并，findlist取交）</p><p><strong>以上主要函数采用for循环，下面的例题采用while循环，相比来说更容易理解，不过for循环也不乏一种思路</strong></p><h2 id="3-一元多项式的相加。"><a href="#3-一元多项式的相加。" class="headerlink" title="3. 一元多项式的相加。"></a>3. 一元多项式的相加。</h2><p>利用两个带头结点的单链表 La 和 Lb 分别存储两个一元多项式 A(x)和 B(x)，对这两个一元<br>多项式求和，输出结果。<br>输入格式：<br>二行数据，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系<br>数和指数，数字间以空格分隔。<br>输出格式：<br>以指数递降方式输出和多项式非零项的系数和指数，数字间以空格分隔。</p><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct LNode &#123;    int xishu;    int zhishu;    struct LNode* next;&#125;LNode, * LinkList; int main()&#123;    void creatlist(LinkList &amp; L, int n);    void printlist(LinkList L);    void unionlist(LinkList &amp; L1, LinkList &amp; L2, LinkList &amp; L3);    int x, y;    LinkList A, B, C;    C = (LinkList)malloc(sizeof(LNode));    C-&gt;next = NULL;    printf(&quot;请输入A数组的长度：\n&quot;);    scanf(&quot;%d&quot;, &amp;x);    creatlist(A,x);    printf(&quot;请输入B数组的长度：\n&quot;);    scanf(&quot;%d&quot;, &amp;y);    creatlist(B, y);    unionlist(A, B, C);    printlist(C);    return 0;&#125; void creatlist(LinkList&amp; L, int n)&#123;    LNode* p = NULL;    LNode* r = NULL;    int i = 0;    L = (LinkList)malloc(sizeof(LNode));    L-&gt;next = NULL;    r = L;    printf(&quot;请输入%d个系数和指数：\n&quot;, n);    for (i = 0; i &lt; n; i++)    &#123;        p = (LinkList)malloc(sizeof(LNode));        p-&gt;next = NULL;        scanf(&quot;%d&quot;, &amp;p-&gt;xishu);        scanf(&quot;%d&quot;, &amp;p-&gt;zhishu);        r-&gt;next = p;        r = p;    &#125;&#125; void printlist(LinkList L)&#123;    LinkList p = NULL;    p = L-&gt;next;    while (p)    &#123;        printf(&quot;%d %d &quot;, p-&gt;xishu, p-&gt;zhishu);        p = p-&gt;next;    &#125;    &#125; void listinsert(LinkList&amp; L, int i, int k,int t)&#123;    LNode* p = NULL;    LNode* q = NULL;    p = L;    int j = 0;    while (p &amp;&amp; j &lt; i - 1)    &#123;        p = p-&gt;next;        j++;    &#125;    q= (LinkList)malloc(sizeof(LNode));    q-&gt;xishu = k;    q-&gt;zhishu = t;    q-&gt;next = p-&gt;next;    p-&gt;next = q;     &#125; void unionlist(LinkList&amp; L1, LinkList&amp; L2, LinkList&amp; L3)&#123;    LinkList p = NULL;    LinkList q = NULL;    int i = 1;    p = L1-&gt;next;    q = L2-&gt;next;    //分成三条路，pq都不为空，p为空q不为空，q为空p不为空    while (p &amp;&amp; q)    &#123;        if (p-&gt;zhishu &lt; q-&gt;zhishu) //p的指数小于q指数，把q指数系数插进去，然后移动q        &#123;            listinsert(L3, i++, q-&gt;xishu,q-&gt;zhishu);            q = q-&gt;next;        &#125;        else if (p-&gt;zhishu &gt; q-&gt;zhishu) &#123;            listinsert(L3, i++, p-&gt;xishu, p-&gt;zhishu);            p = p-&gt;next;        &#125;        else //如果两个指数相等        &#123;            if (p-&gt;xishu + p-&gt;zhishu == 0)//判断系数相加是否为0，为0就不插入了            &#123;                p = p-&gt;next;                q = q-&gt;next;            &#125;            else//不为0则系数相加            &#123;                listinsert(L3, i++, p-&gt;xishu + q-&gt;xishu, p-&gt;zhishu);                p = p-&gt;next;                q = q-&gt;next;            &#125;        &#125;            &#125;    while (p)//p不为空，q为空，把p剩下所有全插进去    &#123;        listinsert(L3, i++, p-&gt;xishu, p-&gt;zhishu);        p = p-&gt;next;    &#125;    while (q)    &#123;        listinsert(L3, i++, q-&gt;xishu, q-&gt;zhishu);        q = q-&gt;next;    &#125;&#125;</code></pre><h2 id="4-约瑟夫-Joseph-问题"><a href="#4-约瑟夫-Joseph-问题" class="headerlink" title="4. 约瑟夫(Joseph)问题"></a>4. 约瑟夫(Joseph)问题</h2><p>[问题描述]<br> 约瑟夫(Joseph)问题的一种描述是：编号为 1，2，…,n 的 n 个人按顺时针方向围坐一圈，<br>每人持有一个密码（正整数），一开始任选一个整数作为报数上限 m,从第一人开始按顺时针方<br>向从自 1 开始顺序报数，报到 m 时停止报数。报 m 的人出列，将他的密码作为新的 m 值，从<br>他的顺时针方向上的下一个人开始重新从 1 报数，如此下去，直至所有人全部出列为止，设计<br>一个程序求出出列顺序。<br>[基本要求]<br>采用单向循环链表模拟此过程,按照出列的顺序打印出各人的编号<br>[实验提示]<br>单向循环链表的结点类型定义参照如下：<br>typedef struct LNode<br>{<br> int code; &#x2F;&#x2F;定义整型变量 code 用来存放序号<br> int key; &#x2F;&#x2F;定义整型变量 key 用来存放密码<br> struct LNode *next;<br>}LNode, *LinkList;</p><p>[测试数据]<br>m的初值为6；n&#x3D;7,7个人的密码依次为：3，1，7，2，4，8， 4，正确的出列顺序应为6,1,4,7,2,3,5。</p><p>输入格式：<br>二行数据，第一行的两个整数分别为 m 和 n 的值，第二行整数 n 个人的密码，两个整数之<br>间以空格分隔。</p><p>输出格式：<br>表示出列顺序，两个整数之间以空格分隔。</p><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef int ElemType;typedef struct LNode&#123;    int code;//存放位置序号    int key;//存放密码    struct LNode* next;&#125;LNode,*LinkList; void creatlist(LinkList&amp; L, int n)//创建一个无头结点的循环链表&#123;    LNode* r = NULL;//指向尾结点    LNode* s = NULL;//指向新结点    int i = 1;    L = (LinkList)malloc(sizeof(LNode));    L-&gt;next = NULL;//L指针域照常还是空    r = L;//尾结点照常还是指向L    L-&gt;code = 1;//要创建无头结点，在for循环外要给L的数据域赋值    scanf(&quot;%d&quot;, &amp;L-&gt;key);    for (i = 1; i &lt; n; i++) &#123;        s = (LinkList)malloc(sizeof(LNode));        s-&gt;code = i + 1;//座次        scanf(&quot;%d&quot;, &amp;s-&gt;key);//输入密码        s-&gt;next = NULL;        r-&gt;next = s;        r = s;    &#125;    r-&gt;next = L;//循环链表尾指针指向首元结点    &#125; void DeleteList(LinkList &amp;L,LinkList&amp; p,LinkList &amp;q, LinkList &amp;r, LinkList&amp; t)&#123;        if(p==L)//如果p是首元结点        &#123;            t=p;//把p存到t中返回            p=p-&gt;next;//p指向下一结点            L=L-&gt;next;//首元结点移动到下一结点            r-&gt;next=L;//尾结点的next域存放首元结点下一结点地址        &#125;//实现了删除,并且该结点被保留在t中            else if(p==r)//当p指向尾结点时        &#123;            r=q;//尾结点是p的前驱结点，也就是q            t=p;            p=p-&gt;next;//p从被删除的结点转向了该结点的下一个结点，即要下一轮开始报数的结点            q-&gt;next=q-&gt;next-&gt;next;//p的前驱结点q改变        &#125;            else        &#123;            t=p;            p=p-&gt;next;//p从被删除的结点转向了该结点的下一个结点，即要下一轮开始报数的结点            q-&gt;next=q-&gt;next-&gt;next;         &#125;&#125; void outlist(LinkList&amp; L, int m, int n)&#123;    LinkList p = NULL;//指向第m结点    LinkList q = NULL;//指向第m-1结点    LinkList t = NULL;//存储返回的结点    LinkList r = NULL;//指向尾结点    p = L;    q = L;    r = L;    int i,j;    for (i = 1; i &lt; n; i++)//指向尾结点，注意无头结点i从1开始        r = r-&gt;next;    for (i = 1; i &lt; m; i++)        p = p-&gt;next;    for (i = 1; i &lt; m - 1; i++)        q = q-&gt;next;    DeleteList(L,p,q, r, t);        printf(&quot;%d &quot;,t-&gt;code);        m=t-&gt;key;            for (i = 1; i &lt; n; i++) &#123;             for (j = 1; j &lt; m; j++)//循环m-1次，p指向循环m-1次后的那个结点                p = p-&gt;next;             for (j = 1; j &lt; m; j++)//这里也是循环m-1次！！！！！！！与p指针位次保持差1                q = q-&gt;next;             DeleteList(L, p, q, r, t);            printf(&quot;%d &quot;, t-&gt;code);            m = t-&gt;key;        &#125;&#125; int main()&#123;    LinkList K;    int m, n;//m是初始报数上限，n是总人数    printf(&quot;请输入初始报数上限m和总人数n:\n&quot;);    scanf(&quot;%d %d&quot;, &amp; m, &amp;n);    printf(&quot;请输入%d个人的密码:\n&quot;, n);    creatlist(K, n);    outlist(K, m, n);    return 0;&#125;</code></pre><p><strong>链表操作时几个注意事项，开始时参数初始化赋值(有头结点）</strong></p><p><em>删除：p&#x3D;L,j&#x3D;0</em></p><p><em>插入：p&#x3D;L，j&#x3D;0</em></p><p><em>求表长：p&#x3D;L-&gt;next,j&#x3D;0</em></p><p><em>打印：p&#x3D;L-&gt;next</em></p><p><strong>链表与顺序表互补，主要删除插入方便，属于顺序存储，之后的图书管理系统与学生管理系统程序会频繁使用</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/05/17/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
      <url>/2022/05/17/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="顺序表例题个人总结"><a href="#顺序表例题个人总结" class="headerlink" title="顺序表例题个人总结"></a>顺序表例题个人总结</h1><p>作为学习数据结构最开始接触的内容，回顾总结时不免感慨万分</p><p>首先先明确要用顺序表解决什么问题，或者说初学者刚接触要能通过顺序表实现什么</p><pre><code>            1.建立顺序表并实现插入、删除、查找            2.删除顺序表中重复元素            3.创造新的顺序表存放合并后的顺序表（交集和并集）            4.通过某种判断方法比较两个顺序表大小</code></pre><p>开始前的知识点补充：引用类型</p><pre><code class="c">#include&lt;stdio.h&gt;void main()&#123;    int i = 5;    int&amp; j = i;    j = 7;    printf(&quot;%d %d&quot;, i, j);&#125;</code></pre><p>输出结果均为7 </p><p>引用类型和实参共用同一个地址，可以像传递指针一样形参该改变实参也改变。</p><p>不同点在于引用类型作为形参，内存中没有产生实参的副本，他直接对实参操作，而一般的变量作为参数形参实参占不同的储存单元，可以理解为他是用来给一个对象提供替代的名字</p><h2 id="1-题目内容：-编程实现顺序表的下列基本操作函数。"><a href="#1-题目内容：-编程实现顺序表的下列基本操作函数。" class="headerlink" title="1.题目内容： 编程实现顺序表的下列基本操作函数。"></a>1.题目内容： 编程实现顺序表的下列基本操作函数。</h2><p>(1) void InitList(SqList &amp; L) &#x2F;&#x2F;建立空的顺序表<br>(2) void ListInsert(SqList &amp; L, int i, ElemType e) &#x2F;&#x2F;在顺序表中第i个位置插入元素函数e<br>(3) void ListDelete(SqList &amp; L, int i, ElemType &amp; e) &#x2F;&#x2F;删除顺序表L的第i个数据元素，并用e返回其值。<br>(4) void PrintList(SqList L) &#x2F;&#x2F; 输出顺序表<br>(5) int Locate(SqList L, ElemType e) &#x2F;&#x2F;若顺序表L中存在数据元素e，则返回e在顺序表L中第一次出现的位序;否则返回0<br>输入格式： 四行数据，第一行的整数表示要建立的顺序表的元素个数，<br>第二行整数表示依次输入的数据，两个整数之间以空格分隔，<br>第三行的整数表示要删除数的位置，第四行表示要查找的数。<br>输出格式： 三行数据，第一行表示程序执行后顺序表的数据元素(依次从表头至表尾), 第<br>二行整数表示已删除的数，第三行表示要查找的数的位置或者没有找到。</p><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define OVERFLOW -2#define ERROR 0#define INIT_LIST_SIZE 6 //初始分配量#define INCREASELIST 3  //分配增量typedef int ElemType; //顺序表中存放的是整数，用ElemType定义int类型，这样以后表达保持代码的统一性typedef struct&#123;    ElemType *elem;  //存储空间基址    ElemType length;  //当前长度    ElemType listsize;  //当前分配的存储容量&#125;SqList;//结构类型名称，注意以后会出现*指针类型，这里未用到int main()&#123;    void InitList(SqList &amp;L);//用引用类型因为要建立顺序表也就是说要改变顺序表    void ListInsert(SqList &amp;L,int i,ElemType e);//这里e没有用引用类型，因为他只需要传值不需要返回    void ListDelete(SqList &amp;L,int i,ElemType &amp;e);//这里用引用类型因为e要储存删除的元素并返回，可以理解为                                                 //传回来时改变了e的值，所以为了获取这个值，用引用类型    void PrintList(SqList L);    int Locate(SqList L,ElemType e);    //函数声明    int n, i;    int e1,e2,t;//e1是已删除的数字，e2是要查找的数,t是要删除元素的位置(位置序号不是下标！)    ElemType x;//声明一个ElemType的数x    SqList K;//初始化顺序表K    InitList(K);//顺序表初始化    printf(&quot;请输入顺序表的元素个数：\n&quot;);    scanf(&quot;%d&quot;,&amp;n);    printf(&quot;请输入%d个元素：\n&quot;,n);    for(i=0;i&lt;n;i++)    &#123;        scanf(&quot;%d&quot;,&amp;x);        ListInsert(K,K.length+1,x);    &#125;    printf(&quot;请输入你想删除的数字的位置：\n&quot;);    scanf(&quot;%d&quot;,&amp;t);    ListDelete(K,t,e1);    printf(&quot;请输入你想查找的数：\n&quot;);    scanf(&quot;%d&quot;,&amp;e2);    printf(&quot;删除后的元素为:\n&quot;);    PrintList(K);    printf(&quot;被删除的元素是：\n&quot;);     printf(&quot;%d\n&quot;,e1);     if(Locate(K,e2)!=0)     &#123;     printf(&quot;要查找数的位置是：\n&quot;);     printf(&quot;%d\n&quot;,Locate(K,e2));    &#125;    else printf(&quot;没有找到\n&quot;);    return 0;&#125;void InitList(SqList &amp;L) //建立空的顺序表//引用参数，对顺序表L的操作会返回给实参&#123;    L.elem=(ElemType*)malloc(INIT_LIST_SIZE*sizeof(ElemType));//为顺序表分配空间    if(!L.elem) exit(OVERFLOW);//如果没有成功分配到，exit    L.length=0;//刚建立的时候顺序表里面没有元素，长度为0    L.listsize=INIT_LIST_SIZE;//建立之后顺序表所占的总空间大小&#125;void ListInsert(SqList &amp;L,int i,ElemType e)&#123;    ElemType *newbase;//初始化新地址    ElemType* p = NULL;//注意指针初始化为空，不然vs容易报错    ElemType* q = NULL;    if(i&lt;1||i&gt;L.length+1)//注意传入的i是为序不是下标，所有从1开始到length+1结束    &#123;    printf(&quot;Insertion location Error!&quot;);    return;//什么也不返回，直接返回主调函数    &#125;    if(L.length&gt;=L.listsize)//如果表长&gt;=其所占空间的长度，那么就要为其分配新的空间，让他还有空间可以存元素    &#123;        newbase=(ElemType*)realloc(L.elem,(L.listsize+INCREASELIST)*sizeof(ElemType));        //realloc函数分配一个listsize+increaselist大小的新内存，并把原来L.base里面数据复制过去        if(!newbase) exit(OVERFLOW);//没分配到就exit        L.elem=newbase;//再令L.base等于newbase，这样相当于重新搞了一个新空间新地址，把原来地址转变成新的地址        L.listsize=L.listsize+INCREASELIST;//分配结束后顺序表总大小相比原来增加了increaselist大小空间    &#125;    q=&amp;(L.elem[i-1]);//q取要插入的位置，注意i是为序，不是下标，对应的第i个下标是i-1    for(p=&amp;(L.elem[L.length-1]);p&gt;=q;--p)//p取表尾    *(p+1)=*p;//从表尾开始移动，表尾元素到表尾后面一个位置，前面依次向后面移动一位    *q=e;//最后第i个与第i+1个元素值都一样，把第i个元素赋值为e    L.length++;//增加了一个元素，表长要+1&#125;void ListDelete(SqList &amp;L,int i,ElemType &amp;e)//删除顺序表L的第i个数据元素，并用e返回其值&#123;    ElemType* p = NULL;    ElemType* q = NULL;    if(i&lt;1||i&gt;L.length)         printf(&quot;删除位置错误\n&quot;);    p=&amp;L.elem[i-1];//p取要删除的元素位置    q=L.elem+L.length-1;//q取表尾元素位置    e=L.elem[i-1];//先储存要删除元素的值    for(;p&lt;q;p++)//这次从删除位置开始，后面的数依次向前移动，第i位的被第i+1位覆盖    *p=*(p+1);    L.length--;//删除了一个数，表长要-1 &#125;void PrintList(SqList L)//输出顺序表&#123;    int i;    for(i=0;i&lt;L.length;i++)    printf(&quot;%d &quot;,L.elem[i]);    printf(&quot;\n&quot;);&#125;int Locate(SqList L,ElemType e)//若顺序表L中存在数据元素e,则返回e在顺序表L中第一次出现的位序，否则返回0&#123;    ElemType *p;    for(p=L.elem;p&lt;L.elem+L.length;p++)    &#123;        if(*p==e)        return (p-L.elem+1);//返回的是为序，要加一        return 0;      &#125;&#125;</code></pre><p><strong>注意删除循环次数要比插入少一次！！！for循环判断时等号两个一个没有一个有</strong> </p><h2 id="2-题目内容：-已知顺序表中的元素依值递增有序排列，要求将x插入到顺序表的适当位置上，"><a href="#2-题目内容：-已知顺序表中的元素依值递增有序排列，要求将x插入到顺序表的适当位置上，" class="headerlink" title="2.题目内容： 已知顺序表中的元素依值递增有序排列，要求将x插入到顺序表的适当位置上，"></a>2.题目内容： 已知顺序表中的元素依值递增有序排列，要求将x插入到顺序表的适当位置上，</h2><p>使得插入操作后的顺序表仍保持有序性。<br> 输入格式： 三行数据，第一行的整数表示要建立的顺序表的元素个数，<br> 第二行整数表示依次输入的数据，两个整数之间以空格分隔，<br> 第三行的整数表示要插入的数x。<br> 输出格式： 一行整数，从表头开始依次显示插入操作后顺序表的数据元素。</p><p>主要函数如下</p><pre><code class="c">void SortListInsert(SqList&amp; L, ElemType e)  &#123;      ElemType* p = NULL;      ElemType* q = NULL;      ElemType* newbase;      int i = 0;      if (L.length &gt;= L.listsize) &#123;          newbase = (ElemType*)realloc(L.elem, (L.listsize +INCREASELIST) * sizeof(ElemType));          L.elem = newbase;          L.listsize = L.listsize +INCREASELIST;      &#125;      for (i = 0; i &lt; L.listsize; i++)      &#123;          if (e &lt;= L.elem[0] &amp;&amp; e &lt; L.elem[1])//之所以这样还附加一个e&lt;L.elem[1]条件是为了减少运算          //如果单纯是第一个条件就判断的话，如果顺序表是2 2 2 3 4 5，你插入2，单凭第一个条件就会插在最          //前面，也就是说你后面所有元素都要移动一次，其实不需要，你如果插在23之间，移动的元素就少了，运算也减少          &#123;              p = L.elem + L.length - 1;//这下面和插入函数是一样的              q = &amp;L.elem[0];              for (; p &gt;= q; p--) &#123;                  *(p + 1) = *p;              &#125;              *q = e;              L.length++;              break;//因为就插入一个元素，完成后跳出结束就行          &#125;          else if (e &gt;= L.elem[i] &amp;&amp; e &lt; L.elem[i + 1])//刚刚例子2 2 2 3 4 5，就进入这里，插在23之间              //注意前取等后不取等          &#123;              p = L.elem + L.length - 1;              q = &amp;(L.elem[i + 1]);//插在i+1处              for (; p &gt;= q; p--) &#123;                  *(p + 1) = *p;              &#125;              *q = e;              L.length++;              break;          &#125;          else if (e &gt;= L.elem[L.length - 1])//如果是2 2 2 2 你插入2也不用担心，你前面两个条件进不去              //这个就相当于插队尾了          &#123;              *(L.elem + L.length) = e;              L.length++;              break;          &#125;      &#125;  &#125;</code></pre><h2 id="3-题目内容：-已知顺序表中的元素依值递增有序排列，"><a href="#3-题目内容：-已知顺序表中的元素依值递增有序排列，" class="headerlink" title="3.题目内容： 已知顺序表中的元素依值递增有序排列，"></a>3.题目内容： 已知顺序表中的元素依值递增有序排列，</h2><p>  要求删除表中所有值相同的多余元素（使得操作后的顺序表中所有元素的值均不相同）<br>   输入样例：  2 5 5 8 11 20 20 20<br>   输出样例： 2 5 8 11 20</p><p>   主要函数如下：</p><pre><code class="c">void deletelist2(Sqlist&amp; L, Elemtype&amp; e)&#123; ElemType* p = NULL; ElemType *q = NULL; int i; for (i = 0; i &lt; L.length-1; i++) &#123;     if (L.elem[i] == L.elem[i + 1])//如果前后两个元素相等，将i+1后面所有元素向前移动一位，把i+1元素覆盖                                     //覆盖i也可以，不过会多一点运算     &#123;         *p = &amp;L.elem[i + 1];         q = L.elem + L.length - 1;         for (; p &lt; q; p++) &#123;             *p = *(p + 1);         &#125;         i--;//原来移动前的第i位还是第i位，不过i+1位变了，再第i位和现在的第i+1位比         L.length--;     &#125; &#125;&#125;</code></pre><h2 id="4-题目内容：-假设以两个元素依值递增有序排列的顺序表A和B"><a href="#4-题目内容：-假设以两个元素依值递增有序排列的顺序表A和B" class="headerlink" title="4.题目内容： 假设以两个元素依值递增有序排列的顺序表A和B"></a>4.题目内容： 假设以两个元素依值递增有序排列的顺序表A和B</h2><pre><code>分别表示两个集合（同一表中的元素值各不相同），现要求另辟空间构成一个顺序表C，其元素为A和B元素的交集，且表C中的元素也是依值递增有序排列。 输入样例： 5 2 5 8 11 20 6 3 8 9 11 15 20 输出样例： 8 11 20</code></pre><h2 id="4’大致如上，不过取并集，也就是输出2-3-5-8-9-11-15-20"><a href="#4’大致如上，不过取并集，也就是输出2-3-5-8-9-11-15-20" class="headerlink" title="4’大致如上，不过取并集，也就是输出2 3 5 8 9 11 15 20"></a>4’大致如上，不过取并集，也就是输出2 3 5 8 9 11 15 20</h2><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define INIT_LIST_SIZE 6#define LISTINCREMENT 3#define OVERFLOW -2typedef int ElemType;typedef struct&#123;        ElemType *elem;        int length;        int listsize;    &#125;SqList;    int main()    &#123;        void InitList(SqList &amp;L);//建立空的顺序表        void ListInsert(SqList &amp;L,int i,ElemType e);//在顺序表中第i个位置插入元素函数e        void PrintList(SqList L);        void ContactList(SqList La,SqList Lb,SqList &amp;Lc);//求线性表A和B的交集        SqList La,Lb,Lc;        ElemType x;        int n,i;        InitList(La);        InitList(Lb);        printf(&quot;请输入顺序表A的元素个数：\n&quot;);        scanf(&quot;%d&quot;,&amp;n);        printf(&quot;请输入顺序表A中的元素：\n&quot;);        for(i=0;i&lt;n;i++)        &#123;            scanf(&quot;%d&quot;,&amp;x);            ListInsert(La,La.length+1,x);        &#125;        printf(&quot;请输入顺序表B的元素个数：\n&quot;);        scanf(&quot;%d&quot;,&amp;n);        printf(&quot;请输入顺序表B中的元素：\n&quot;);        for(i=0;i&lt;n;i++)        &#123;            scanf(&quot;%d&quot;,&amp;x);            ListInsert(Lb,Lb.length+1,x);        &#125;        ContactList(La,Lb,Lc);        PrintList(Lc);        return 0;     &#125;    void InitList(SqList &amp;L)    &#123;        L.elem=(ElemType*)malloc(INIT_LIST_SIZE*sizeof(ElemType));        if(!L.elem) exit(OVERFLOW);        L.length=0;        L.listsize=INIT_LIST_SIZE;     &#125;     void ListInsert(SqList &amp;L,int i,ElemType e)     &#123;        ElemType *newbase;        ElemType *q,*p;        if(i&lt;1||i&gt;L.length+1)        printf(&quot;Insertion Location Error!\n&quot;);        if(L.length&gt;=L.listsize)        &#123;            newbase=(ElemType*)realloc(L.elem,(L.listsize+LISTINCREMENT)*sizeof(ElemType));            L.elem=newbase;            L.listsize = L.listsize + LISTINCREMENT;         &#125;         q=&amp;L.elem[i-1];//q指向要插入的位置         for(p=L.elem+L.length-1;p&gt;=q;p--)            *(p+1)=*p;        *q=e;        L.length++;     &#125;    void PrintList(SqList L)    &#123;        int i;        for(i=0;i&lt;L.length;i++)        printf(&quot;%d &quot;,L.elem[i]);     &#125;     /*void ContactList(SqList La,SqList Lb,SqList &amp;Lc)//取交集     &#123;        ElemType *pa,*pb,*pc;        pa=La.elem;        pb=Lb.elem;        if(La.length&gt;=Lb.length)        Lc.listsize=Lb.length;        else        Lc.listsize=La.length;        Lc.elem=(ElemType*)malloc(Lc.listsize*sizeof(ElemType));        if(!Lc.elem) exit(OVERFLOW);        Lc.length=0;        pc=Lc.elem;        while(pa&lt;=La.elem+La.length-1&amp;&amp;pb&lt;=Lb.elem+Lb.length-1)        &#123;            if(*pa&lt;*pb)            pa++;            else if(*pa&gt;*pb)            pb++;            else            &#123;                *pc=*pa;                pa++;                pb++;                pc++;                Lc.length++;             &#125;         &#125;     &#125;*/    void ContactList(SqList La, SqList Lb, SqList&amp; Lc)//取并集            &#123;                ElemType* p = NULL;                ElemType* q = NULL;                ElemType* r = NULL;                p = La.elem;                q = Lb.elem;                Lc .listsize = La.length + Lb.length;                Lc.elem = (ElemType*)malloc(Lc.listsize * sizeof(ElemType));                if (!Lc.elem) exit(OVERFLOW);                Lc.length = 0;                r = Lc.elem;                while ((p &lt;= La.elem + La.length - 1 )&amp;&amp; (q &lt;= Lb.elem + Lb.length - 1))//若都未指向空                &#123;                    if (*p &lt; *q) &#123;                        *r++ = *p++;//*r=*q;r++;q++                        Lc.length++;                    &#125;                    else if (*p &gt; *q) &#123;                        *r++ = *q++;                        Lc.length++;                    &#125;                    else &#123;                        *r++ = *p++;                        q++;                        Lc.length++;                    &#125;                &#125;                while (p &lt;= La.elem + La.length-1)//如果p没指空，L2空了，把L1剩下的全插入L3                &#123;                    *r++ = *p++;                    Lc.length++;                &#125;                while (q &lt;= Lb.elem + Lb.length-1)                &#123;                    *r++ = *q++;                    Lc.length++;                &#125;                                                    &#125;</code></pre><h2 id="5-题目内容：-设A-x3D-a1-…-am-和B-x3D-b1-…-bn-均为顺序表，"><a href="#5-题目内容：-设A-x3D-a1-…-am-和B-x3D-b1-…-bn-均为顺序表，" class="headerlink" title="5.题目内容： 设A&#x3D;(a1,…,am)和B&#x3D;(b1,…,bn)均为顺序表，"></a>5.题目内容： 设A&#x3D;(a1,…,am)和B&#x3D;(b1,…,bn)均为顺序表，</h2><pre><code>A’和B’分别为A和B中除去最大共同前缀后的子表，若A’＝B’＝空表，则A=B;若A’=空表，而B’!=空表，或者两者都不为空表，且A’的首元小于B’的首元，则A&lt;B;否则A &gt;B. 试编程，求出A,B的大小。</code></pre><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define INIT_LIST_SIZE 6#define LISTINCREMENT 3#define OVERFLOW -2typedef int ElemType;  typedef struct&#123;      ElemType *elem;      int length;      int listsize;  &#125;SqList;  int main()  &#123;      void InitList(SqList &amp;L);      void ListInsert(SqList &amp;L,int i,ElemType e);      int CompareList(SqList L1,SqList L2);      int a,b,i,x;      SqList L1,L2;      InitList(L1);      InitList(L2);      printf(&quot;请输入顺序表A的元素个数：\n&quot;);      scanf(&quot;%d&quot;,&amp;a);      printf(&quot;请输入顺序表A的所有元素：\n&quot;);      for(i=0;i&lt;a;i++)      &#123;          scanf(&quot;%d&quot;,&amp;x);          ListInsert(L1,L1.length+1,x);      &#125;      printf(&quot;请输入顺序表B的元素个数：\n&quot;);      scanf(&quot;%d&quot;,&amp;b);      printf(&quot;请输入顺序表B的所有元素:\n&quot;);      for(i=0;i&lt;b;i++)      &#123;          scanf(&quot;%d&quot;,&amp;x);          ListInsert(L2,L2.length+1,x);      &#125;      int k = CompareList(L1, L2);      if (k == 1)          printf(&quot;a&gt;b&quot;);      if (k == -1)          printf(&quot;a&lt;b&quot;);      else          printf(&quot;a=b&quot;);      return 0;  &#125;  void InitList(SqList &amp;L)  &#123;      L.elem=(ElemType*)malloc(INIT_LIST_SIZE*sizeof(ElemType));      if(!L.elem) exit(OVERFLOW);      L.length=0;      L.listsize=INIT_LIST_SIZE;  &#125;  void ListInsert(SqList &amp;L,int i,ElemType e)  &#123;      ElemType *newbase;      ElemType *p,*q;      if(i&lt;1||i&gt;L.length+1)      printf(&quot;Insertion Location Error!\n&quot;);      if(L.length&gt;=L.listsize)      &#123;          newbase=(ElemType*)realloc(L.elem,(L.listsize+LISTINCREMENT)*sizeof(ElemType));          L.elem = newbase;          L.listsize = L.listsize + LISTINCREMENT;      &#125;      q=&amp;L.elem[i-1];      for(p=L.elem+L.length-1;p&gt;=q;p--)          *(p+1)=*p;          *q=e;          L.length++;  &#125;  int CompareList(SqList L1, SqList L2)  &#123;      ElemType* p = NULL;      ElemType* q = NULL;      p = L1.elem;      q = L2.elem;      while (p &lt; L1.elem + L1.length &amp;&amp; q &lt; L2.elem + L2.length)//pq都没指空      &#123;          if (*p &lt; *q)//p在该位置的值小于q，A就小于B              return -1;          else if (*p &gt; *q)              return 1;          else//如果相等比较下面一个位置的元素的值          &#123;              p++;              q++;          &#125;      &#125;      if (p == L1.elem + L1.length &amp;&amp; q == L2.elem + L2.length)//两个同时指空，则A=B          return 0;      else if (p == L1.elem + L1.length)//如果p空了，此时q没空，A&lt;B          return -1;      else          return 1;  &#125;</code></pre><p>以上是5个常见的情况例题</p><p>掌握顺序表在于理解操作的意义，比如插入删除从什么开始，进行多少次，位序和下标的关系，再就是注意切入方法，当然简单的方法需要更高的思维层次，从最基础做起，慢慢领悟才是常态<br><strong>顺序表特点是利用元素的存储位置表示线性表中相邻元素的前后关系（逻辑结构与存储结构一致）<br>顺序表优点是随机存取，存储密度大，但是插入删除需移动大量元素，浪费存储空间，而且属于静态存储形式，元素个数不能自由扩充，下面将引入的链表刚好和其互补</strong></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
